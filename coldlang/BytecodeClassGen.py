
bytecode_classes = []

acc_read = 'AccumulatorUse::Read'
acc_write = 'AccumulatorUse::Write'
acc_none = 'AccumulatorUse::None'
acc_read_write = 'AccumulatorUse::ReadWrite'

variable = 'OperandType::Variable*'
literal = 'OperandType::Literal*'
label = 'OperandType::Label*'
constant = 'OperandType::Constant*'
native_func = 'OperandType::NativeFunction*'

head =\
"""\
#pragma once
#include "stdafx.h"
#include "BytecodeByteDump.h"

/* this is auto-generated by BytecodeClassGen.py */

namespace IR
{
	namespace BytecodeClass
	{
"""

tail =\
"""\
    }
}
"""

enums =\
"""\
        enum BytecodeEnum {
%(enum_list)s        };
"""

class_template =\
"""\
		class %(bytecode_name)s : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
            size_t byte_len;
            %(bytecode_param_list)s;
		public:
			%(bytecode_name)s(%(bytecode_param_list)s) 
                %(init_list)s
            {
                byte_len = params_to_byte(byte_buf, Enum%(bytecode_name)s%(bytecode_param_name_list)s);
            }

            size_t dump_byte(char out_buf[]) override
            {
                memcpy(out_buf, byte_buf, byte_len);
			    return byte_len;
            }

            wstring get_name() override
            {
                return L"%(bytecode_name)s";
            }

			wstring to_string() override
			{
				return get_name() + %(serialize_params)s;
			}
		};
"""

emit_template =\
"""\
        

"""

head = head.replace('\t', ' '*4)
tail = tail.replace('\t', ' '*4)
class_template = class_template.replace('\t', ' '*4)

def get_enums():
    enum_list = [' ' * 12 + 'Enum%s, \n' % c['class_name'] for c in bytecode_classes]    
    return enums % {
        'enum_list': ''.join(enum_list)
    }


def generate_class_from_param(bytecode_class):
    class_name = bytecode_class['class_name']
    acc_use = bytecode_class['acc_use']
    op_types = bytecode_class['op_types']

    parameter_list = generate_parameter_list(op_types)
    name_list = generate_name_list(op_types)
    init_list = generate_init_list(name_list, name_list)
    # print(name_list)
    return class_template % {
        'bytecode_name': class_name,
        'bytecode_param_list': ', '.join(parameter_list),
        'bytecode_param_name_list': '' if len(name_list) == 0 else ', ' + ', '.join(name_list),
        'serialize_params': string_sum(name_list),
        'init_list': '' if len(init_list) == 0 else ': ' + init_list
    }


def bytecode_def(class_name: str, acc_use: str, op_types: list = None):
    bytecode_classes.append({
        'class_name': class_name,
        'acc_use': acc_use,
        'op_types': [] if op_types == None else op_types
    })

def bytecode_def_unary(class_prefix: str, acc_use: str):
    b = bytecode_def
    b(class_prefix + 'Variable', acc_use, [variable])
    b(class_prefix + 'Literal', acc_use, [literal])
    b(class_prefix + 'Constant', acc_use, [constant])

def generate_parameter_list(op_types: list, prefix = "param"):
    parameter_list = []
    for id, op in enumerate(op_types):
        parameter_list.append("%s %s" % (op, prefix + str(id+1)))
    return parameter_list

def generate_name_list(op_types: list, prefix = "param"):
    parameter_list = []
    for id, op in enumerate(op_types):
        parameter_list.append("%s" % (prefix + str(id+1)))
    return parameter_list

def generate_init_list(names: list, params: list):
    pairs = []
    for i in range(len(names)):
        name = names[i]
        param = params[i]
        pairs.append('%s(%s)' % (name, param))
    return ', '.join(pairs)

def string_sum(param_name_list):
    if len(param_name_list) > 0:
        return 'L" " + ' + ' + L" " + '.join([x + '->to_string()' for x in param_name_list])
    else:
        return 'L""'
    
#print(generate_parameter_list([variable, constant]))

def define():
    b = bytecode_def
    bu = bytecode_def_unary
    b('CallFunc', acc_write, [variable])
    b('CallNative', acc_write, [native_func])
    b('RetAcc', acc_read)
    bu('PushParam', acc_read_write)
    b('PushParamAcc', acc_read)
    b('Jump', acc_none, [label])
    b('JumpOnTrue', acc_read, [label])
    b('JumpOnFalse', acc_read, [label])
    bu('Or', acc_read_write)
    bu('And', acc_read_write)
    bu('Equal', acc_read_write)
    bu('NotEqual', acc_read_write)
    bu('GreaterEqual', acc_read_write)
    bu('LessEqual', acc_read_write)
    bu('GreaterThan', acc_read_write)
    bu('LessThan', acc_read_write)
    bu('Add', acc_read_write)
    bu('Sub', acc_read_write)
    bu('Mul', acc_read_write)
    bu('Div', acc_read_write)
    bu('Mod', acc_read_write)
    b('Inc', acc_write, [variable])
    b('Decre', acc_write, [variable])
    bu('Neg', acc_write)
    bu('LoadToAcc', acc_write)
    bu('StoreAcc', acc_read)

define()

print(head)
print(get_enums())
for bytecode_class in bytecode_classes:
    print(generate_class_from_param(bytecode_class))
print(tail)