
bytecode_classes = []

acc_read = 'AccumulatorUse::Read'
acc_write = 'AccumulatorUse::Write'
acc_none = 'AccumulatorUse::None'
acc_read_write = 'AccumulatorUse::ReadWrite'

variable = 'OperandType::Variable*'
literal = 'OperandType::Literal*'
label = 'OperandType::Label*'
constant = 'OperandType::Constant*'
native_func = 'OperandType::NativeFunction*'

head =\
"""\
#pragma once
#include "stdafx.h"
#include "BytecodeByteDump.h"
#include "Variable.h"
#include "BytecodeBase.h"
#include "BytecodeWriter.h"
#include "IRGenerator.h"
#include "Literal.h"
#include "Constant.h"
#include "Label.h"
/* this is auto-generated by BytecodeClassGen.py */

namespace IR
{
	namespace BytecodeClass
	{
"""

tail =\
"""\
    }
}
"""

enums =\
"""\
        enum BytecodeEnum {
%(enum_list)s        };
"""

class_template =\
"""\
		class %(bytecode_name)s : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
            size_t byte_len;
            %(bytecode_param_list)s;
		public:
			%(bytecode_name)s(%(bytecode_param_list)s) 
                %(init_list)s
            {
                byte_len = params_to_byte(byte_buf, Enum%(bytecode_name)s%(bytecode_param_name_list)s);
            }

            size_t dump_byte(unsigned char out_buf[]) override
            {
                memcpy(out_buf, byte_buf, byte_len);
			    return byte_len;
            }

            wstring get_name() override
            {
                return L"%(bytecode_name)s";
            }

			wstring to_string() override
			{
				return get_name() + %(serialize_params)s;
			}
		};
"""

head = head.replace('\t', ' '*4)
tail = tail.replace('\t', ' '*4)
class_template = class_template.replace('\t', ' '*4)

emit_template_declare =\
"""\
		template<typename VCode>
		inline void emit(BytecodeWriter * bw, OperandType::Symbol* param);
""".replace('\t', ' '*4)

emit_template_define =\
"""\
		template<>
		inline void emit<%(virtual_name)s>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
%(type_select_list)s
		}\
""".replace('\t', ' '*4)

emit_type_selete_template =\
"""\
            if (auto t = dynamic_cast<%(op_type)s>(param))
			{
				EMIT(%(bytecode_name)s, bw, t);
			}
""".replace('\t', ' '*4)

virtual_bytecode_class_template =\
"""\
        class %s {};\
""".replace('\t', ' '*4)

acc_use =\
"""
namespace IR
{
	namespace AccumulatorUse
	{
		enum Type {
			None = 0,
			Read = 1 << 0,
			Write = 1 << 1,
			ReadWrite = Read | Write
		};
	}
}

""".replace('\t', ' '*4)

bytecode_list_header =\
"""\
#define BYTECODE_LIST(C)\\"""

bytecode_list_entry_template =\
"""\
        C(%(bytecode_name)s, %(acc_use)s%(arg_list)s)\\"""

emit_template_list = []
virtual_bytecode_class = []
bytecode_list = []

def get_enums():
    enum_list = [' ' * 12 + 'Enum%s, \n' % c['class_name'] for c in bytecode_classes]    
    return enums % {
        'enum_list': ''.join(enum_list)
    }


def generate_class_from_param(bytecode_class):
    class_name = bytecode_class['class_name']
    acc_use = bytecode_class['acc_use']
    op_types = bytecode_class['op_types']

    parameter_list = generate_parameter_list(op_types)
    name_list = generate_name_list(op_types)
    init_list = generate_init_list(name_list, name_list)

    bytecode_list.append(bytecode_list_entry_template % {
        'bytecode_name': class_name,
        'acc_use': acc_use,
        'arg_list': '' if len(op_types) == 0 else ', ' + ', '.join(op_types)
    })
    # print(name_list)
    return class_template % {
        'bytecode_name': class_name,
        'bytecode_param_list': ', '.join(parameter_list),
        'bytecode_param_name_list': '' if len(name_list) == 0 else ', ' + ', '.join(name_list),
        'serialize_params': string_sum(name_list),
        'init_list': '' if len(init_list) == 0 else ': ' + init_list
    }

def bytecode_def(class_name: str, acc_use: str, op_types: list = None):
    bytecode_classes.append({
        'class_name': class_name,
        'acc_use': acc_use,
        'op_types': [] if op_types == None else op_types
    })


def bytecode_def_unary(class_prefix: str, acc_use: str):
    b = bytecode_def

    virtual_bytecode_class.append(virtual_bytecode_class_template % class_prefix)

    type_select_list = []
    for suffix, op_type in [
        ('Variable', variable), ('Literal', literal), ('Constant', constant)
        ]:

        b(class_prefix + suffix, acc_use, [op_type])

        type_select_list.append(emit_type_selete_template %
        {
            'bytecode_name': class_prefix + suffix,
            'op_type': op_type
        })
    
    
    emit_template_list.append(
        emit_template_define % {
            'virtual_name': class_prefix,
            'type_select_list': ''.join(type_select_list),
        }
    )

def generate_parameter_list(op_types: list, prefix = "param"):
    parameter_list = []
    for id, op in enumerate(op_types):
        parameter_list.append("%s %s" % (op, prefix + str(id+1)))
    return parameter_list

def generate_name_list(op_types: list, prefix = "param"):
    parameter_list = []
    for id, op in enumerate(op_types):
        parameter_list.append("%s" % (prefix + str(id+1)))
    return parameter_list

def generate_init_list(names: list, params: list):
    pairs = []
    for i in range(len(names)):
        name = names[i]
        param = params[i]
        pairs.append('%s(%s)' % (name, param))
    return ', '.join(pairs)

def string_sum(param_name_list):
    if len(param_name_list) > 0:
        return 'L" " + ' + ' + L" " + '.join([x + '->to_string()' for x in param_name_list])
    else:
        return 'L""'
    
#print(generate_parameter_list([variable, constant]))

def define():
    b = bytecode_def
    bu = bytecode_def_unary
    b('CallFunc', acc_write, [variable])
    b('CallNative', acc_write, [native_func])
    b('RetAcc', acc_read)
    bu('PushParam', acc_read_write)
    b('PushParamAcc', acc_read)
    b('Jump', acc_none, [label])
    b('JumpOnTrue', acc_read, [label])
    b('JumpOnFalse', acc_read, [label])
    bu('Or', acc_read_write)
    bu('And', acc_read_write)
    bu('Equal', acc_read_write)
    bu('NotEqual', acc_read_write)
    bu('GreaterEqual', acc_read_write)
    bu('LessEqual', acc_read_write)
    bu('GreaterThan', acc_read_write)
    bu('LessThan', acc_read_write)
    bu('Add', acc_read_write)
    bu('Sub', acc_read_write)
    bu('Mul', acc_read_write)
    bu('Div', acc_read_write)
    bu('Mod', acc_read_write)
    b('Inc', acc_write, [variable])
    b('Decre', acc_write, [variable])
    bu('Neg', acc_write)
    bu('LoadToAcc', acc_write)
    bu('StoreAcc', acc_read)

define()

print(head)
print(get_enums())
for bytecode_class in bytecode_classes:
    print(generate_class_from_param(bytecode_class))
for virtual_class in virtual_bytecode_class:
    print(virtual_class)
print(emit_template_declare)
for emit_template in emit_template_list:
    print(emit_template)
print(bytecode_list_header)
for bytecode in bytecode_list:
    print(bytecode)
print("")
print(tail)

print(acc_use)