#pragma once
#include "stdafx.h"
#include "BytecodeByteDump.h"

/* this is auto-generated by BytecodeClassGen.py */

namespace IR
{
	namespace BytecodeClass
	{

		enum BytecodeEnum {
			EnumCallFunc,
			EnumCallNative,
			EnumRetAcc,
			EnumPushParamVariable,
			EnumPushParamLiteral,
			EnumPushParamConstant,
			EnumPushParamAcc,
			EnumJump,
			EnumJumpOnTrue,
			EnumJumpOnFalse,
			EnumOrVariable,
			EnumOrLiteral,
			EnumOrConstant,
			EnumAndVariable,
			EnumAndLiteral,
			EnumAndConstant,
			EnumEqualVariable,
			EnumEqualLiteral,
			EnumEqualConstant,
			EnumNotEqualVariable,
			EnumNotEqualLiteral,
			EnumNotEqualConstant,
			EnumGreaterEqualVariable,
			EnumGreaterEqualLiteral,
			EnumGreaterEqualConstant,
			EnumLessEqualVariable,
			EnumLessEqualLiteral,
			EnumLessEqualConstant,
			EnumGreaterThanVariable,
			EnumGreaterThanLiteral,
			EnumGreaterThanConstant,
			EnumLessThanVariable,
			EnumLessThanLiteral,
			EnumLessThanConstant,
			EnumAddVariable,
			EnumAddLiteral,
			EnumAddConstant,
			EnumSubVariable,
			EnumSubLiteral,
			EnumSubConstant,
			EnumMulVariable,
			EnumMulLiteral,
			EnumMulConstant,
			EnumDivVariable,
			EnumDivLiteral,
			EnumDivConstant,
			EnumModVariable,
			EnumModLiteral,
			EnumModConstant,
			EnumInc,
			EnumDecre,
			EnumNegVariable,
			EnumNegLiteral,
			EnumNegConstant,
			EnumLoadToAccVariable,
			EnumLoadToAccLiteral,
			EnumLoadToAccConstant,
			EnumStoreAccVariable,
			EnumStoreAccLiteral,
			EnumStoreAccConstant,
		};

		class CallFunc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			CallFunc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumCallFunc, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"CallFunc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class CallNative : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::NativeFunction* param1;
		public:
			CallNative(OperandType::NativeFunction* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumCallNative, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"CallNative";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class RetAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			;
		public:
			RetAcc()

			{
				byte_len = params_to_byte(byte_buf, EnumRetAcc);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"RetAcc";
			}

			wstring to_string() override
			{
				return get_name() + L"";
			}
		};

		class PushParamVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			PushParamVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			PushParamLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			PushParamConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			;
		public:
			PushParamAcc()

			{
				byte_len = params_to_byte(byte_buf, EnumPushParamAcc);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamAcc";
			}

			wstring to_string() override
			{
				return get_name() + L"";
			}
		};

		class Jump : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			Jump(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJump, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Jump";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class JumpOnTrue : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			JumpOnTrue(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJumpOnTrue, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"JumpOnTrue";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class JumpOnFalse : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			JumpOnFalse(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJumpOnFalse, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"JumpOnFalse";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			OrVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			OrLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			OrConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			AndVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			AndLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			AndConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			EqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			EqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			EqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			NotEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			NotEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			NotEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			GreaterEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			GreaterEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			GreaterEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			LessEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			LessEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			LessEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			GreaterThanVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			GreaterThanLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			GreaterThanConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			LessThanVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			LessThanLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			LessThanConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			AddVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			AddLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			AddConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			SubVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			SubLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			SubConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			MulVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			MulLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			MulConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			DivVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			DivLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			DivConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			ModVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			ModLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			ModConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Inc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			Inc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumInc, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Inc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Decre : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			Decre(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDecre, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Decre";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			NegVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			NegLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			NegConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			LoadToAccVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			LoadToAccLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			LoadToAccConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAccVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			StoreAccVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAccVariable, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAccVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAccLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			StoreAccLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAccLiteral, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAccLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAccConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			StoreAccConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAccConstant, param1);
			}

			size_t dump_byte(char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAccConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

	}
}

