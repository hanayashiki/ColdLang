#pragma once
#include "stdafx.h"
#include "BytecodeByteDump.h"
#include "Variable.h"
#include "BytecodeBase.h"
#include "BytecodeWriter.h"
#include "IRGenerator.h"
#include "Literal.h"
#include "Constant.h"
#include "Label.h"

/* this is auto-generated by BytecodeClassGen.py */

namespace IR
{
	namespace BytecodeClass
	{

		enum BytecodeEnum {
			EnumPushParamVariable,
			EnumPushParamLiteral,
			EnumPushParamConstant,
			EnumOrVariable,
			EnumOrLiteral,
			EnumOrConstant,
			EnumAndVariable,
			EnumAndLiteral,
			EnumAndConstant,
			EnumEqualVariable,
			EnumEqualLiteral,
			EnumEqualConstant,
			EnumNotEqualVariable,
			EnumNotEqualLiteral,
			EnumNotEqualConstant,
			EnumGreaterEqualVariable,
			EnumGreaterEqualLiteral,
			EnumGreaterEqualConstant,
			EnumLessEqualVariable,
			EnumLessEqualLiteral,
			EnumLessEqualConstant,
			EnumGreaterThanVariable,
			EnumGreaterThanLiteral,
			EnumGreaterThanConstant,
			EnumLessThanVariable,
			EnumLessThanLiteral,
			EnumLessThanConstant,
			EnumAddVariable,
			EnumAddLiteral,
			EnumAddConstant,
			EnumSubVariable,
			EnumSubLiteral,
			EnumSubConstant,
			EnumMulVariable,
			EnumMulLiteral,
			EnumMulConstant,
			EnumDivVariable,
			EnumDivLiteral,
			EnumDivConstant,
			EnumModVariable,
			EnumModLiteral,
			EnumModConstant,
			EnumNegVariable,
			EnumNegLiteral,
			EnumNegConstant,
			EnumLoadToAccVariable,
			EnumLoadToAccLiteral,
			EnumLoadToAccConstant,
			EnumStoreAcc,
			EnumCallFunc,
			EnumCallNative,
			EnumRetAcc,
			EnumPushParamAcc,
			EnumJump,
			EnumJumpOnTrue,
			EnumJumpOnFalse,
			EnumInc,
			EnumDecre,
			EnumLabel,
		};

		enum OpType {
			OpMove,
			OpLogicalOr,
			OpLogicalAnd,
			OpEqual,
			OpNotEqual,
			OpGreaterEqual,
			OpLessEqual,
			OpGreaterThan,
			OpLessThan,
			OpAdd,
			OpSub,
			OpMul,
			OpDiv,
			OpMod,
			OpNeg,
		};

		static const char * OpTypeName[] = {
			"OpMove",
			"OpLogicalOr",
			"OpLogicalAnd",
			"OpEqual",
			"OpNotEqual",
			"OpGreaterEqual",
			"OpLessEqual",
			"OpGreaterThan",
			"OpLessThan",
			"OpAdd",
			"OpSub",
			"OpMul",
			"OpDiv",
			"OpMod",
			"OpNeg",
		};

		class PushParamVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumPushParamVariable;
			PushParamVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumPushParamLiteral;
			PushParamLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumPushParamConstant;
			PushParamConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumOrVariable;
			OrVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumOrLiteral;
			OrLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumOrConstant;
			OrConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumAndVariable;
			AndVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumAndLiteral;
			AndLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumAndConstant;
			AndConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumEqualVariable;
			EqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumEqualLiteral;
			EqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumEqualConstant;
			EqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumNotEqualVariable;
			NotEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumNotEqualLiteral;
			NotEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumNotEqualConstant;
			NotEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumGreaterEqualVariable;
			GreaterEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumGreaterEqualLiteral;
			GreaterEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumGreaterEqualConstant;
			GreaterEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumLessEqualVariable;
			LessEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumLessEqualLiteral;
			LessEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumLessEqualConstant;
			LessEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumGreaterThanVariable;
			GreaterThanVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumGreaterThanLiteral;
			GreaterThanLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumGreaterThanConstant;
			GreaterThanConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumLessThanVariable;
			LessThanVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumLessThanLiteral;
			LessThanLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumLessThanConstant;
			LessThanConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumAddVariable;
			AddVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumAddLiteral;
			AddLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumAddConstant;
			AddConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumSubVariable;
			SubVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumSubLiteral;
			SubLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumSubConstant;
			SubConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumMulVariable;
			MulVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumMulLiteral;
			MulLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumMulConstant;
			MulConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumDivVariable;
			DivVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumDivLiteral;
			DivLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumDivConstant;
			DivConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumModVariable;
			ModVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumModLiteral;
			ModLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumModConstant;
			ModConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumNegVariable;
			NegVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumNegLiteral;
			NegLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumNegConstant;
			NegConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccVariable : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumLoadToAccVariable;
			LoadToAccVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccLiteral : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			static const unsigned char code_id = EnumLoadToAccLiteral;
			LoadToAccLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccConstant : public BytecodeUnary
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			static const unsigned char code_id = EnumLoadToAccConstant;
			LoadToAccConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumStoreAcc;
			StoreAcc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAcc, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAcc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class CallFunc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumCallFunc;
			CallFunc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumCallFunc, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"CallFunc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class CallNative : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::NativeFunction* param1;
		public:
			static const unsigned char code_id = EnumCallNative;
			CallNative(OperandType::NativeFunction* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumCallNative, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"CallNative";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class RetAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			;
		public:
			static const unsigned char code_id = EnumRetAcc;
			RetAcc()

			{
				byte_len = params_to_byte(byte_buf, EnumRetAcc);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"RetAcc";
			}

			wstring to_string() override
			{
				return get_name() + L"";
			}
		};

		class PushParamAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			;
		public:
			static const unsigned char code_id = EnumPushParamAcc;
			PushParamAcc()

			{
				byte_len = params_to_byte(byte_buf, EnumPushParamAcc);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamAcc";
			}

			wstring to_string() override
			{
				return get_name() + L"";
			}
		};

		class Jump : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			static const unsigned char code_id = EnumJump;
			Jump(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJump, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Jump";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class JumpOnTrue : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			static const unsigned char code_id = EnumJumpOnTrue;
			JumpOnTrue(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJumpOnTrue, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"JumpOnTrue";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class JumpOnFalse : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			static const unsigned char code_id = EnumJumpOnFalse;
			JumpOnFalse(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJumpOnFalse, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"JumpOnFalse";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Inc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumInc;
			Inc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumInc, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Inc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Decre : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			static const unsigned char code_id = EnumDecre;
			Decre(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDecre, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Decre";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Label : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			static const unsigned char code_id = EnumLabel;
			Label(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLabel, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Label";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParam {};
		class Or {};
		class And {};
		class Equal {};
		class NotEqual {};
		class GreaterEqual {};
		class LessEqual {};
		class GreaterThan {};
		class LessThan {};
		class Add {};
		class Sub {};
		class Mul {};
		class Div {};
		class Mod {};
		class Neg {};
		class LoadToAcc {};
		template<typename VCode>
		inline void emit(BytecodeWriter * bw, OperandType::Symbol* param);

		template<>
		inline void emit<PushParam>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(PushParamVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(PushParamLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(PushParamConstant, bw, t);
			}

		}
		template<>
		inline void emit<Or>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(OrVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(OrLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(OrConstant, bw, t);
			}

		}
		template<>
		inline void emit<And>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(AndVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(AndLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(AndConstant, bw, t);
			}

		}
		template<>
		inline void emit<Equal>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(EqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(EqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(EqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<NotEqual>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(NotEqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(NotEqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(NotEqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<GreaterEqual>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(GreaterEqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(GreaterEqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(GreaterEqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<LessEqual>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(LessEqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(LessEqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(LessEqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<GreaterThan>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(GreaterThanVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(GreaterThanLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(GreaterThanConstant, bw, t);
			}

		}
		template<>
		inline void emit<LessThan>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(LessThanVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(LessThanLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(LessThanConstant, bw, t);
			}

		}
		template<>
		inline void emit<Add>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(AddVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(AddLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(AddConstant, bw, t);
			}

		}
		template<>
		inline void emit<Sub>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(SubVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(SubLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(SubConstant, bw, t);
			}

		}
		template<>
		inline void emit<Mul>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(MulVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(MulLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(MulConstant, bw, t);
			}

		}
		template<>
		inline void emit<Div>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(DivVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(DivLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(DivConstant, bw, t);
			}

		}
		template<>
		inline void emit<Mod>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(ModVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(ModLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(ModConstant, bw, t);
			}

		}
		template<>
		inline void emit<Neg>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(NegVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(NegLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(NegConstant, bw, t);
			}

		}
		template<>
		inline void emit<LoadToAcc>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(LoadToAccVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(LoadToAccLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(LoadToAccConstant, bw, t);
			}

		}
#define BYTECODE_LIST(C)\
        C(PushParamVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(PushParamLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(PushParamConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(OrVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(OrLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(OrConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(AndVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(AndLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(AndConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(EqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(EqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(EqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(NotEqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(NotEqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(NotEqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(GreaterEqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(GreaterEqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(GreaterEqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(LessEqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(LessEqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(LessEqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(GreaterThanVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(GreaterThanLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(GreaterThanConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(LessThanVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(LessThanLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(LessThanConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(AddVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(AddLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(AddConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(SubVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(SubLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(SubConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(MulVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(MulLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(MulConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(DivVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(DivLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(DivConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(ModVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(ModLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(ModConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(NegVariable, AccumulatorUse::Write, OperandType::Variable*)\
        C(NegLiteral, AccumulatorUse::Write, OperandType::Literal*)\
        C(NegConstant, AccumulatorUse::Write, OperandType::Constant*)\
        C(LoadToAccVariable, AccumulatorUse::Write, OperandType::Variable*)\
        C(LoadToAccLiteral, AccumulatorUse::Write, OperandType::Literal*)\
        C(LoadToAccConstant, AccumulatorUse::Write, OperandType::Constant*)\
        C(StoreAcc, AccumulatorUse::Read, OperandType::Variable*)\
        C(CallFunc, AccumulatorUse::Write, OperandType::Variable*)\
        C(CallNative, AccumulatorUse::Write, OperandType::NativeFunction*)\
        C(RetAcc, AccumulatorUse::Read)\
        C(PushParamAcc, AccumulatorUse::Read)\
        C(Jump, AccumulatorUse::None, OperandType::Label*)\
        C(JumpOnTrue, AccumulatorUse::Read, OperandType::Label*)\
        C(JumpOnFalse, AccumulatorUse::Read, OperandType::Label*)\
        C(Inc, AccumulatorUse::Write, OperandType::Variable*)\
        C(Decre, AccumulatorUse::Write, OperandType::Variable*)\
        C(Label, AccumulatorUse::None, OperandType::Label*)\

		static UnaryBytecodeInfo get_unary_info_PushParamVariable(unsigned char buf[])
		{
			return {
				OpMove, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_PushParamLiteral(unsigned char buf[])
		{
			return {
				OpMove, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_PushParamConstant(unsigned char buf[])
		{
			return {
				OpMove, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_OrVariable(unsigned char buf[])
		{
			return {
				OpLogicalOr, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_OrLiteral(unsigned char buf[])
		{
			return {
				OpLogicalOr, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_OrConstant(unsigned char buf[])
		{
			return {
				OpLogicalOr, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_AndVariable(unsigned char buf[])
		{
			return {
				OpLogicalAnd, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_AndLiteral(unsigned char buf[])
		{
			return {
				OpLogicalAnd, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_AndConstant(unsigned char buf[])
		{
			return {
				OpLogicalAnd, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_EqualVariable(unsigned char buf[])
		{
			return {
				OpEqual, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_EqualLiteral(unsigned char buf[])
		{
			return {
				OpEqual, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_EqualConstant(unsigned char buf[])
		{
			return {
				OpEqual, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_NotEqualVariable(unsigned char buf[])
		{
			return {
				OpNotEqual, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_NotEqualLiteral(unsigned char buf[])
		{
			return {
				OpNotEqual, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_NotEqualConstant(unsigned char buf[])
		{
			return {
				OpNotEqual, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_GreaterEqualVariable(unsigned char buf[])
		{
			return {
				OpGreaterEqual, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_GreaterEqualLiteral(unsigned char buf[])
		{
			return {
				OpGreaterEqual, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_GreaterEqualConstant(unsigned char buf[])
		{
			return {
				OpGreaterEqual, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LessEqualVariable(unsigned char buf[])
		{
			return {
				OpLessEqual, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LessEqualLiteral(unsigned char buf[])
		{
			return {
				OpLessEqual, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LessEqualConstant(unsigned char buf[])
		{
			return {
				OpLessEqual, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_GreaterThanVariable(unsigned char buf[])
		{
			return {
				OpGreaterThan, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_GreaterThanLiteral(unsigned char buf[])
		{
			return {
				OpGreaterThan, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_GreaterThanConstant(unsigned char buf[])
		{
			return {
				OpGreaterThan, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LessThanVariable(unsigned char buf[])
		{
			return {
				OpLessThan, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LessThanLiteral(unsigned char buf[])
		{
			return {
				OpLessThan, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LessThanConstant(unsigned char buf[])
		{
			return {
				OpLessThan, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_AddVariable(unsigned char buf[])
		{
			return {
				OpAdd, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_AddLiteral(unsigned char buf[])
		{
			return {
				OpAdd, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_AddConstant(unsigned char buf[])
		{
			return {
				OpAdd, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_SubVariable(unsigned char buf[])
		{
			return {
				OpSub, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_SubLiteral(unsigned char buf[])
		{
			return {
				OpSub, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_SubConstant(unsigned char buf[])
		{
			return {
				OpSub, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_MulVariable(unsigned char buf[])
		{
			return {
				OpMul, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_MulLiteral(unsigned char buf[])
		{
			return {
				OpMul, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_MulConstant(unsigned char buf[])
		{
			return {
				OpMul, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_DivVariable(unsigned char buf[])
		{
			return {
				OpDiv, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_DivLiteral(unsigned char buf[])
		{
			return {
				OpDiv, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_DivConstant(unsigned char buf[])
		{
			return {
				OpDiv, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_ModVariable(unsigned char buf[])
		{
			return {
				OpMod, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_ModLiteral(unsigned char buf[])
		{
			return {
				OpMod, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_ModConstant(unsigned char buf[])
		{
			return {
				OpMod, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_NegVariable(unsigned char buf[])
		{
			return {
				OpNeg, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_NegLiteral(unsigned char buf[])
		{
			return {
				OpNeg, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_NegConstant(unsigned char buf[])
		{
			return {
				OpNeg, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LoadToAccVariable(unsigned char buf[])
		{
			return {
				OpMove, retrieve_arg<OperandType::Variable*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LoadToAccLiteral(unsigned char buf[])
		{
			return {
				OpMove, retrieve_arg<OperandType::Literal*>(&buf[1])
			};
		}


		static UnaryBytecodeInfo get_unary_info_LoadToAccConstant(unsigned char buf[])
		{
			return {
				OpMove, retrieve_arg<OperandType::Constant*>(&buf[1])
			};
		}


		typedef UnaryBytecodeInfo(*GetUnaryInfo)(unsigned char[]);
		const GetUnaryInfo get_unary_info_list[] = {
			get_unary_info_PushParamVariable,
			get_unary_info_PushParamLiteral,
			get_unary_info_PushParamConstant,
			get_unary_info_OrVariable,
			get_unary_info_OrLiteral,
			get_unary_info_OrConstant,
			get_unary_info_AndVariable,
			get_unary_info_AndLiteral,
			get_unary_info_AndConstant,
			get_unary_info_EqualVariable,
			get_unary_info_EqualLiteral,
			get_unary_info_EqualConstant,
			get_unary_info_NotEqualVariable,
			get_unary_info_NotEqualLiteral,
			get_unary_info_NotEqualConstant,
			get_unary_info_GreaterEqualVariable,
			get_unary_info_GreaterEqualLiteral,
			get_unary_info_GreaterEqualConstant,
			get_unary_info_LessEqualVariable,
			get_unary_info_LessEqualLiteral,
			get_unary_info_LessEqualConstant,
			get_unary_info_GreaterThanVariable,
			get_unary_info_GreaterThanLiteral,
			get_unary_info_GreaterThanConstant,
			get_unary_info_LessThanVariable,
			get_unary_info_LessThanLiteral,
			get_unary_info_LessThanConstant,
			get_unary_info_AddVariable,
			get_unary_info_AddLiteral,
			get_unary_info_AddConstant,
			get_unary_info_SubVariable,
			get_unary_info_SubLiteral,
			get_unary_info_SubConstant,
			get_unary_info_MulVariable,
			get_unary_info_MulLiteral,
			get_unary_info_MulConstant,
			get_unary_info_DivVariable,
			get_unary_info_DivLiteral,
			get_unary_info_DivConstant,
			get_unary_info_ModVariable,
			get_unary_info_ModLiteral,
			get_unary_info_ModConstant,
			get_unary_info_NegVariable,
			get_unary_info_NegLiteral,
			get_unary_info_NegConstant,
			get_unary_info_LoadToAccVariable,
			get_unary_info_LoadToAccLiteral,
			get_unary_info_LoadToAccConstant,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr
		};

		static GetUnaryInfo get_get_unary_info(unsigned char buf[]) {
			unsigned char code_id = buf[0];
			GetUnaryInfo getter = get_unary_info_list[code_id];
			assert(getter != nullptr);
			return getter;
		}

		static bool is_unary(const unsigned char buf[]) {
			unsigned char code_id = buf[0];
			return code_id >= PushParamVariable::code_id && code_id <= LoadToAccConstant::code_id;
		}


		static wstring get_enum_name(BytecodeEnum bytecode_enum) {
			switch (bytecode_enum) {
			case EnumPushParamVariable:
				return L"PushParamVariable";
				break;
			case EnumPushParamLiteral:
				return L"PushParamLiteral";
				break;
			case EnumPushParamConstant:
				return L"PushParamConstant";
				break;
			case EnumOrVariable:
				return L"OrVariable";
				break;
			case EnumOrLiteral:
				return L"OrLiteral";
				break;
			case EnumOrConstant:
				return L"OrConstant";
				break;
			case EnumAndVariable:
				return L"AndVariable";
				break;
			case EnumAndLiteral:
				return L"AndLiteral";
				break;
			case EnumAndConstant:
				return L"AndConstant";
				break;
			case EnumEqualVariable:
				return L"EqualVariable";
				break;
			case EnumEqualLiteral:
				return L"EqualLiteral";
				break;
			case EnumEqualConstant:
				return L"EqualConstant";
				break;
			case EnumNotEqualVariable:
				return L"NotEqualVariable";
				break;
			case EnumNotEqualLiteral:
				return L"NotEqualLiteral";
				break;
			case EnumNotEqualConstant:
				return L"NotEqualConstant";
				break;
			case EnumGreaterEqualVariable:
				return L"GreaterEqualVariable";
				break;
			case EnumGreaterEqualLiteral:
				return L"GreaterEqualLiteral";
				break;
			case EnumGreaterEqualConstant:
				return L"GreaterEqualConstant";
				break;
			case EnumLessEqualVariable:
				return L"LessEqualVariable";
				break;
			case EnumLessEqualLiteral:
				return L"LessEqualLiteral";
				break;
			case EnumLessEqualConstant:
				return L"LessEqualConstant";
				break;
			case EnumGreaterThanVariable:
				return L"GreaterThanVariable";
				break;
			case EnumGreaterThanLiteral:
				return L"GreaterThanLiteral";
				break;
			case EnumGreaterThanConstant:
				return L"GreaterThanConstant";
				break;
			case EnumLessThanVariable:
				return L"LessThanVariable";
				break;
			case EnumLessThanLiteral:
				return L"LessThanLiteral";
				break;
			case EnumLessThanConstant:
				return L"LessThanConstant";
				break;
			case EnumAddVariable:
				return L"AddVariable";
				break;
			case EnumAddLiteral:
				return L"AddLiteral";
				break;
			case EnumAddConstant:
				return L"AddConstant";
				break;
			case EnumSubVariable:
				return L"SubVariable";
				break;
			case EnumSubLiteral:
				return L"SubLiteral";
				break;
			case EnumSubConstant:
				return L"SubConstant";
				break;
			case EnumMulVariable:
				return L"MulVariable";
				break;
			case EnumMulLiteral:
				return L"MulLiteral";
				break;
			case EnumMulConstant:
				return L"MulConstant";
				break;
			case EnumDivVariable:
				return L"DivVariable";
				break;
			case EnumDivLiteral:
				return L"DivLiteral";
				break;
			case EnumDivConstant:
				return L"DivConstant";
				break;
			case EnumModVariable:
				return L"ModVariable";
				break;
			case EnumModLiteral:
				return L"ModLiteral";
				break;
			case EnumModConstant:
				return L"ModConstant";
				break;
			case EnumNegVariable:
				return L"NegVariable";
				break;
			case EnumNegLiteral:
				return L"NegLiteral";
				break;
			case EnumNegConstant:
				return L"NegConstant";
				break;
			case EnumLoadToAccVariable:
				return L"LoadToAccVariable";
				break;
			case EnumLoadToAccLiteral:
				return L"LoadToAccLiteral";
				break;
			case EnumLoadToAccConstant:
				return L"LoadToAccConstant";
				break;
			case EnumStoreAcc:
				return L"StoreAcc";
				break;
			case EnumCallFunc:
				return L"CallFunc";
				break;
			case EnumCallNative:
				return L"CallNative";
				break;
			case EnumRetAcc:
				return L"RetAcc";
				break;
			case EnumPushParamAcc:
				return L"PushParamAcc";
				break;
			case EnumJump:
				return L"Jump";
				break;
			case EnumJumpOnTrue:
				return L"JumpOnTrue";
				break;
			case EnumJumpOnFalse:
				return L"JumpOnFalse";
				break;
			case EnumInc:
				return L"Inc";
				break;
			case EnumDecre:
				return L"Decre";
				break;
			case EnumLabel:
				return L"Label";
				break;
			default:
				assert(false);
			}
		}

		static wstring decompile(const unsigned char buf[])
		{
			wstring str;
			switch (buf[0])
			{
			case EnumPushParamVariable:
				str = get_enum_name(EnumPushParamVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumPushParamLiteral:
				str = get_enum_name(EnumPushParamLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumPushParamConstant:
				str = get_enum_name(EnumPushParamConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumOrVariable:
				str = get_enum_name(EnumOrVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumOrLiteral:
				str = get_enum_name(EnumOrLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumOrConstant:
				str = get_enum_name(EnumOrConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumAndVariable:
				str = get_enum_name(EnumAndVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumAndLiteral:
				str = get_enum_name(EnumAndLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumAndConstant:
				str = get_enum_name(EnumAndConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumEqualVariable:
				str = get_enum_name(EnumEqualVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumEqualLiteral:
				str = get_enum_name(EnumEqualLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumEqualConstant:
				str = get_enum_name(EnumEqualConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumNotEqualVariable:
				str = get_enum_name(EnumNotEqualVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumNotEqualLiteral:
				str = get_enum_name(EnumNotEqualLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumNotEqualConstant:
				str = get_enum_name(EnumNotEqualConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumGreaterEqualVariable:
				str = get_enum_name(EnumGreaterEqualVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumGreaterEqualLiteral:
				str = get_enum_name(EnumGreaterEqualLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumGreaterEqualConstant:
				str = get_enum_name(EnumGreaterEqualConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumLessEqualVariable:
				str = get_enum_name(EnumLessEqualVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumLessEqualLiteral:
				str = get_enum_name(EnumLessEqualLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumLessEqualConstant:
				str = get_enum_name(EnumLessEqualConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumGreaterThanVariable:
				str = get_enum_name(EnumGreaterThanVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumGreaterThanLiteral:
				str = get_enum_name(EnumGreaterThanLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumGreaterThanConstant:
				str = get_enum_name(EnumGreaterThanConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumLessThanVariable:
				str = get_enum_name(EnumLessThanVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumLessThanLiteral:
				str = get_enum_name(EnumLessThanLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumLessThanConstant:
				str = get_enum_name(EnumLessThanConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumAddVariable:
				str = get_enum_name(EnumAddVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumAddLiteral:
				str = get_enum_name(EnumAddLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumAddConstant:
				str = get_enum_name(EnumAddConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumSubVariable:
				str = get_enum_name(EnumSubVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumSubLiteral:
				str = get_enum_name(EnumSubLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumSubConstant:
				str = get_enum_name(EnumSubConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumMulVariable:
				str = get_enum_name(EnumMulVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumMulLiteral:
				str = get_enum_name(EnumMulLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumMulConstant:
				str = get_enum_name(EnumMulConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumDivVariable:
				str = get_enum_name(EnumDivVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumDivLiteral:
				str = get_enum_name(EnumDivLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumDivConstant:
				str = get_enum_name(EnumDivConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumModVariable:
				str = get_enum_name(EnumModVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumModLiteral:
				str = get_enum_name(EnumModLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumModConstant:
				str = get_enum_name(EnumModConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumNegVariable:
				str = get_enum_name(EnumNegVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumNegLiteral:
				str = get_enum_name(EnumNegLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumNegConstant:
				str = get_enum_name(EnumNegConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumLoadToAccVariable:
				str = get_enum_name(EnumLoadToAccVariable) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumLoadToAccLiteral:
				str = get_enum_name(EnumLoadToAccLiteral) + L" " + retrieve_arg<OperandType::Literal*>(buf + 1)->to_string();
				break;
			case EnumLoadToAccConstant:
				str = get_enum_name(EnumLoadToAccConstant) + L" " + retrieve_arg<OperandType::Constant*>(buf + 1)->to_string();
				break;
			case EnumStoreAcc:
				str = get_enum_name(EnumStoreAcc) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumCallFunc:
				str = get_enum_name(EnumCallFunc) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumCallNative:
				str = get_enum_name(EnumCallNative) + L" " + retrieve_arg<OperandType::NativeFunction*>(buf + 1)->to_string();
				break;
			case EnumRetAcc:
				str = get_enum_name(EnumRetAcc);
				break;
			case EnumPushParamAcc:
				str = get_enum_name(EnumPushParamAcc);
				break;
			case EnumJump:
				str = get_enum_name(EnumJump) + L" " + retrieve_arg<OperandType::Label*>(buf + 1)->to_string();
				break;
			case EnumJumpOnTrue:
				str = get_enum_name(EnumJumpOnTrue) + L" " + retrieve_arg<OperandType::Label*>(buf + 1)->to_string();
				break;
			case EnumJumpOnFalse:
				str = get_enum_name(EnumJumpOnFalse) + L" " + retrieve_arg<OperandType::Label*>(buf + 1)->to_string();
				break;
			case EnumInc:
				str = get_enum_name(EnumInc) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumDecre:
				str = get_enum_name(EnumDecre) + L" " + retrieve_arg<OperandType::Variable*>(buf + 1)->to_string();
				break;
			case EnumLabel:
				str = get_enum_name(EnumLabel) + L" " + retrieve_arg<OperandType::Label*>(buf + 1)->to_string();
				break;
			default:
				assert(false);
			}
			return str;
		}

	}
}


namespace IR
{
	namespace AccumulatorUse
	{
		enum Type {
			None = 0,
			Read = 1 << 0,
			Write = 1 << 1,
			ReadWrite = Read | Write
		};
	}
}


