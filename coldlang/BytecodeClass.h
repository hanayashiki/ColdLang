#pragma once
#include "stdafx.h"
#include "BytecodeByteDump.h"
#include "Variable.h"
#include "BytecodeBase.h"
#include "BytecodeWriter.h"
#include "IRGenerator.h"
#include "Literal.h"
#include "Constant.h"
#include "Label.h"
/* this is auto-generated by BytecodeClassGen.py */

namespace IR
{
	namespace BytecodeClass
	{

		enum BytecodeEnum {
			EnumCallFunc,
			EnumCallNative,
			EnumRetAcc,
			EnumPushParamVariable,
			EnumPushParamLiteral,
			EnumPushParamConstant,
			EnumPushParamAcc,
			EnumJump,
			EnumJumpOnTrue,
			EnumJumpOnFalse,
			EnumOrVariable,
			EnumOrLiteral,
			EnumOrConstant,
			EnumAndVariable,
			EnumAndLiteral,
			EnumAndConstant,
			EnumEqualVariable,
			EnumEqualLiteral,
			EnumEqualConstant,
			EnumNotEqualVariable,
			EnumNotEqualLiteral,
			EnumNotEqualConstant,
			EnumGreaterEqualVariable,
			EnumGreaterEqualLiteral,
			EnumGreaterEqualConstant,
			EnumLessEqualVariable,
			EnumLessEqualLiteral,
			EnumLessEqualConstant,
			EnumGreaterThanVariable,
			EnumGreaterThanLiteral,
			EnumGreaterThanConstant,
			EnumLessThanVariable,
			EnumLessThanLiteral,
			EnumLessThanConstant,
			EnumAddVariable,
			EnumAddLiteral,
			EnumAddConstant,
			EnumSubVariable,
			EnumSubLiteral,
			EnumSubConstant,
			EnumMulVariable,
			EnumMulLiteral,
			EnumMulConstant,
			EnumDivVariable,
			EnumDivLiteral,
			EnumDivConstant,
			EnumModVariable,
			EnumModLiteral,
			EnumModConstant,
			EnumInc,
			EnumDecre,
			EnumNegVariable,
			EnumNegLiteral,
			EnumNegConstant,
			EnumLoadToAccVariable,
			EnumLoadToAccLiteral,
			EnumLoadToAccConstant,
			EnumStoreAccVariable,
			EnumStoreAccLiteral,
			EnumStoreAccConstant,
		};

		class CallFunc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			CallFunc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumCallFunc, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"CallFunc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class CallNative : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::NativeFunction* param1;
		public:
			CallNative(OperandType::NativeFunction* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumCallNative, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"CallNative";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class RetAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			;
		public:
			RetAcc()

			{
				byte_len = params_to_byte(byte_buf, EnumRetAcc);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"RetAcc";
			}

			wstring to_string() override
			{
				return get_name() + L"";
			}
		};

		class PushParamVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			PushParamVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			PushParamLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			PushParamConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumPushParamConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParamAcc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			;
		public:
			PushParamAcc()

			{
				byte_len = params_to_byte(byte_buf, EnumPushParamAcc);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"PushParamAcc";
			}

			wstring to_string() override
			{
				return get_name() + L"";
			}
		};

		class Jump : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			Jump(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJump, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Jump";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class JumpOnTrue : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			JumpOnTrue(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJumpOnTrue, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"JumpOnTrue";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class JumpOnFalse : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Label* param1;
		public:
			JumpOnFalse(OperandType::Label* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumJumpOnFalse, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"JumpOnFalse";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			OrVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			OrLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class OrConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			OrConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumOrConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"OrConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			AndVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			AndLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AndConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			AndConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAndConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AndConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			EqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			EqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class EqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			EqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"EqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			NotEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			NotEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NotEqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			NotEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNotEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NotEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			GreaterEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			GreaterEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterEqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			GreaterEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			LessEqualVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			LessEqualLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessEqualConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			LessEqualConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessEqualConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessEqualConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			GreaterThanVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			GreaterThanLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class GreaterThanConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			GreaterThanConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumGreaterThanConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"GreaterThanConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			LessThanVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			LessThanLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LessThanConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			LessThanConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLessThanConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LessThanConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			AddVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			AddLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class AddConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			AddConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumAddConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"AddConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			SubVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			SubLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class SubConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			SubConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumSubConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"SubConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			MulVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			MulLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class MulConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			MulConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumMulConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"MulConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			DivVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			DivLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class DivConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			DivConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDivConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"DivConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			ModVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			ModLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class ModConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			ModConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumModConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"ModConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Inc : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			Inc(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumInc, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Inc";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class Decre : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			Decre(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumDecre, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"Decre";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			NegVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			NegLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class NegConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			NegConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumNegConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"NegConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			LoadToAccVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			LoadToAccLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class LoadToAccConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			LoadToAccConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumLoadToAccConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"LoadToAccConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAccVariable : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Variable* param1;
		public:
			StoreAccVariable(OperandType::Variable* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAccVariable, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAccVariable";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAccLiteral : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Literal* param1;
		public:
			StoreAccLiteral(OperandType::Literal* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAccLiteral, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAccLiteral";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class StoreAccConstant : public BytecodeBase
		{
		private:
			unsigned char byte_buf[128];
			size_t byte_len;
			OperandType::Constant* param1;
		public:
			StoreAccConstant(OperandType::Constant* param1)
				: param1(param1)
			{
				byte_len = params_to_byte(byte_buf, EnumStoreAccConstant, param1);
			}

			size_t dump_byte(unsigned char out_buf[]) override
			{
				memcpy(out_buf, byte_buf, byte_len);
				return byte_len;
			}

			wstring get_name() override
			{
				return L"StoreAccConstant";
			}

			wstring to_string() override
			{
				return get_name() + L" " + param1->to_string();
			}
		};

		class PushParam {};
		class Or {};
		class And {};
		class Equal {};
		class NotEqual {};
		class GreaterEqual {};
		class LessEqual {};
		class GreaterThan {};
		class LessThan {};
		class Add {};
		class Sub {};
		class Mul {};
		class Div {};
		class Mod {};
		class Neg {};
		class LoadToAcc {};
		class StoreAcc {};
		template<typename VCode>
		inline void emit(BytecodeWriter * bw, OperandType::Symbol* param);

		template<>
		inline void emit<PushParam>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(PushParamVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(PushParamLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(PushParamConstant, bw, t);
			}

		}
		template<>
		inline void emit<Or>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(OrVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(OrLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(OrConstant, bw, t);
			}

		}
		template<>
		inline void emit<And>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(AndVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(AndLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(AndConstant, bw, t);
			}

		}
		template<>
		inline void emit<Equal>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(EqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(EqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(EqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<NotEqual>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(NotEqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(NotEqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(NotEqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<GreaterEqual>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(GreaterEqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(GreaterEqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(GreaterEqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<LessEqual>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(LessEqualVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(LessEqualLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(LessEqualConstant, bw, t);
			}

		}
		template<>
		inline void emit<GreaterThan>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(GreaterThanVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(GreaterThanLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(GreaterThanConstant, bw, t);
			}

		}
		template<>
		inline void emit<LessThan>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(LessThanVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(LessThanLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(LessThanConstant, bw, t);
			}

		}
		template<>
		inline void emit<Add>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(AddVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(AddLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(AddConstant, bw, t);
			}

		}
		template<>
		inline void emit<Sub>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(SubVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(SubLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(SubConstant, bw, t);
			}

		}
		template<>
		inline void emit<Mul>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(MulVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(MulLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(MulConstant, bw, t);
			}

		}
		template<>
		inline void emit<Div>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(DivVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(DivLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(DivConstant, bw, t);
			}

		}
		template<>
		inline void emit<Mod>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(ModVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(ModLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(ModConstant, bw, t);
			}

		}
		template<>
		inline void emit<Neg>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(NegVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(NegLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(NegConstant, bw, t);
			}

		}
		template<>
		inline void emit<LoadToAcc>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(LoadToAccVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(LoadToAccLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(LoadToAccConstant, bw, t);
			}

		}
		template<>
		inline void emit<StoreAcc>(BytecodeWriter * bw, OperandType::Symbol* param)
		{
			if (auto t = dynamic_cast<OperandType::Variable*>(param))
			{
				EMIT(StoreAccVariable, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Literal*>(param))
			{
				EMIT(StoreAccLiteral, bw, t);
			}
			if (auto t = dynamic_cast<OperandType::Constant*>(param))
			{
				EMIT(StoreAccConstant, bw, t);
			}

		}
#define BYTECODE_LIST(C)\
        C(CallFunc, AccumulatorUse::Write, OperandType::Variable*)\
        C(CallNative, AccumulatorUse::Write, OperandType::NativeFunction*)\
        C(RetAcc, AccumulatorUse::Read)\
        C(PushParamVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(PushParamLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(PushParamConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(PushParamAcc, AccumulatorUse::Read)\
        C(Jump, AccumulatorUse::None, OperandType::Label*)\
        C(JumpOnTrue, AccumulatorUse::Read, OperandType::Label*)\
        C(JumpOnFalse, AccumulatorUse::Read, OperandType::Label*)\
        C(OrVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(OrLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(OrConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(AndVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(AndLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(AndConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(EqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(EqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(EqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(NotEqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(NotEqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(NotEqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(GreaterEqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(GreaterEqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(GreaterEqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(LessEqualVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(LessEqualLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(LessEqualConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(GreaterThanVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(GreaterThanLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(GreaterThanConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(LessThanVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(LessThanLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(LessThanConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(AddVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(AddLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(AddConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(SubVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(SubLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(SubConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(MulVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(MulLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(MulConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(DivVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(DivLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(DivConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(ModVariable, AccumulatorUse::ReadWrite, OperandType::Variable*)\
        C(ModLiteral, AccumulatorUse::ReadWrite, OperandType::Literal*)\
        C(ModConstant, AccumulatorUse::ReadWrite, OperandType::Constant*)\
        C(Inc, AccumulatorUse::Write, OperandType::Variable*)\
        C(Decre, AccumulatorUse::Write, OperandType::Variable*)\
        C(NegVariable, AccumulatorUse::Write, OperandType::Variable*)\
        C(NegLiteral, AccumulatorUse::Write, OperandType::Literal*)\
        C(NegConstant, AccumulatorUse::Write, OperandType::Constant*)\
        C(LoadToAccVariable, AccumulatorUse::Write, OperandType::Variable*)\
        C(LoadToAccLiteral, AccumulatorUse::Write, OperandType::Literal*)\
        C(LoadToAccConstant, AccumulatorUse::Write, OperandType::Constant*)\
        C(StoreAccVariable, AccumulatorUse::Read, OperandType::Variable*)\
        C(StoreAccLiteral, AccumulatorUse::Read, OperandType::Literal*)\
        C(StoreAccConstant, AccumulatorUse::Read, OperandType::Constant*)\

	}
}


namespace IR
{
	namespace AccumulatorUse
	{
		enum Type {
			None = 0,
			Read = 1 << 0,
			Write = 1 << 1,
			ReadWrite = Read | Write
		};
	}
}


