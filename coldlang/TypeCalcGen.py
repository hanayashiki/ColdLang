value_types =\
"""
	enum ValueType
	{
		AnyVal = 1,
		IntegerVal = 2,
		FloatVal,
		BooleanVal,
		NoneVal,
		StringPointerVal,
		FunctionPointerVal,
		ObjectPointerVal,
		ErrorVal
	};
"""

op_types =\
"""
    enum OpType {
		OpLogicalOr,
		OpLogicalAnd,
		OpEqual,
		OpNotEqual,
		OpGreaterEqual,
		OpLessEqual,
		OpGreaterThan,
		OpLessThan,
		OpAdd,
		OpSub,
		OpMul,
		OpDiv,
		OpMod,
		OpNeg,
		OpMove,
	};
"""

head=\
"""\
#pragma once
#include "stdafx.h"
#include "RuntimeObject.h"

/* This is auto-generated by TypeCalcGen.py */

namespace CldRuntime
{
	class TypeCalc
	{
	private:
		static const size_t op_type_count = %d;
		static const size_t value_type_count = %d;
""".replace('\t', 4*' ')

template =\
"""\
        inline static const CldRuntime::ValueType op_val_val_to_res_val[op_type_count][value_type_count][value_type_count] = { %(mat)s };\
""".replace('\t', 4*' ')

tail =\
"""\
	public:
		static CldRuntime::ValueType get_result_type(IR::BytecodeClass::OpType op, CldRuntime::ValueType left, CldRuntime::ValueType right)
		{
			return op_val_val_to_res_val[op][left][right];
		}
	};
}\
""".replace('\t', 4*' ')

import re

def withNamespace(value_types : list, namespace : str):
    return [namespace + '::' + x for x in value_types]

value_types = withNamespace(re.findall(r'[a-zA-Z]+', value_types), 'CldRuntime')[2:]

(Any, Int, Float, Bool, Non, StrPtr, FuncPtr, ObjPtr, Err) = value_types

value_type_to_index = dict(zip(value_types, range(0, len(value_types))))
# print(value_types)

(_, _, OpLogicalOr, OpLogicalAnd, OpEqual, OpNotEqual, 
    OpGreaterEqual, OpLessEqual, OpGreaterThan, OpLessThan, OpAdd, OpSub, OpMul, OpDiv, OpMod, OpNeg, OpMove) =\
    re.findall(r'[a-zA-Z]+', op_types)

op_types = re.findall(r'[a-zA-Z]+', op_types)[2:]
op_type_to_index = dict(zip(op_types, range(0, len(op_types))))

All = None

# [(LeftVal, OpType, RightVal), ResVal]
calc_def = [
    
    [(Any, All, All), Any],

    [(FuncPtr, OpMove, All), FuncPtr],

    [(ObjPtr, OpMove, All), ObjPtr],

    [(StrPtr, OpMove, All), StrPtr],
    [(StrPtr, OpAdd, Int), StrPtr],
    [(StrPtr, OpAdd, Float), StrPtr],
    [(StrPtr, OpAdd, Non), StrPtr],
    [(StrPtr, OpAdd, StrPtr), StrPtr],
    [(StrPtr, OpAdd, FuncPtr), StrPtr],
    [(StrPtr, OpAdd, ObjPtr), StrPtr],

    [(StrPtr, OpMul, Int), StrPtr],

    [(StrPtr, OpEqual, StrPtr), Bool],
    [(StrPtr, OpNotEqual, StrPtr), Bool],
    [(StrPtr, OpGreaterEqual, StrPtr), Bool],
    [(StrPtr, OpLessEqual, StrPtr), Bool],
    [(StrPtr, OpGreaterThan, StrPtr), Bool],
    [(StrPtr, OpLessThan, StrPtr), Bool],

    [(Non, OpMove, All), Non],
    [(Non, OpEqual, All), Bool],
    [(Non, OpNotEqual, All), Bool],
    [(Non, All, All), Err],

    [(Bool, OpMove, All), Bool],
    [(Bool, OpEqual, Bool), Bool],
    [(Bool, OpNotEqual, Bool), Bool],
    [(Bool, OpLogicalAnd, Bool), Bool],
    [(Bool, OpLogicalOr, Bool), Bool],

    [(Float, OpMove, All), Float],
    [(Float, OpAdd, Float), Float],
    [(Float, OpAdd, Int), Float],
    [(Float, OpSub, Float), Float],
    [(Float, OpSub, Int), Float],
    [(Float, OpMul, Float), Float],
    [(Float, OpMul, Int), Float],
    [(Float, OpDiv, Float), Float],
    [(Float, OpDiv, Int), Float],

    [(Float, OpNeg, All), Float],

    [(Float, OpGreaterEqual, Float), Bool],
    [(Float, OpGreaterEqual, Int), Bool],
    [(Float, OpGreaterThan, Float), Bool],
    [(Float, OpGreaterThan, Int), Bool],
    [(Float, OpLessEqual, Float), Bool],
    [(Float, OpLessEqual, Int), Bool],
    [(Float, OpLessThan, Float), Bool],
    [(Float, OpLessThan, Int), Bool],

    [(Int, OpMove, All), Int],
    [(Int, OpAdd, Int), Int],
    [(Int, OpSub, Int), Int],
    [(Int, OpMul, Int), Int],
    [(Int, OpDiv, Int), Int],
    [(Int, OpMod, Int), Int],

    [(Int, OpGreaterEqual, Int), Bool],
    [(Int, OpGreaterThan, Int), Bool],
    [(Int, OpLessEqual, Int), Bool],
    [(Int, OpLessThan, Int), Bool],

    [(Int, OpNeg, All), Int],

    [(FuncPtr, All, All), Err],
        [(ObjPtr, All, All), Any],

    [(All, All, All), Err],
]

import numpy as np

op_left_right = np.zeros((len(op_types), len(value_types), len(value_types)), dtype=np.int8)

def fill(o_l_r: np.array, l_o_r: tuple, res: int):
    # o_l_r is the op * value * value tensor
    # l_o_r is the defined input type
    # res is the defined output type
    op_index = All if l_o_r[1] == All else op_type_to_index[l_o_r[1]]
    l_index = All if l_o_r[0] == All else value_type_to_index[l_o_r[0]]
    r_index = All if l_o_r[2] == All else value_type_to_index[l_o_r[2]]
    fill_one(o_l_r, res, op_index, l_index, r_index)
    fill_one(o_l_r, res, op_index, r_index, l_index)

def fill_one(o_l_r: np.array, value: int, op_index, l_index, r_index):
    if op_index == All:
        (op_start, op_end) = (0, len(op_types))
    else:
        (op_start, op_end) = op_index, op_index + 1
    if l_index == All:
        (l_start, l_end) = (0, len(value_types))  
    else:
        (l_start, l_end) = l_index, l_index + 1
    if r_index == All:
        (r_start, r_end) = (0, len(value_types)) 
    else:
        (r_start, r_end) =  r_index, r_index + 1
    o_l_r[op_start:op_end, l_start:l_end, r_start:r_end] = value

for def_entry in reversed(calc_def):
    (left, op, right) = def_entry[0]
    res = value_type_to_index[def_entry[1]]
    fill(op_left_right, (left, op, right), res)

def look_up(op: str, left: str, right: str):
    return value_types[int(op_left_right[op_type_to_index[op], value_type_to_index[left], value_type_to_index[right]])]

# check
for def_enty in calc_def:
    (left, op, right) = def_entry[0]
    if left and op and right:
        res = value_type_to_index[def_entry[1]]
        assert(look_up(op, left, right) == res)

# res_type_init_arr = [value_types[index] for index in np.nditer(op_left_right)]
res_type_init_arr = [value_types[int(index)] for index in np.nditer(op_left_right)]

print(head % (len(op_types), len(value_types)))
print(template % { 'mat': ', '.join(res_type_init_arr) })
print(tail)
